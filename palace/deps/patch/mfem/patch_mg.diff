diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index ed23e47c0..405f37c18 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -208,10 +208,6 @@ public:
                                             Vector &x, Vector &b,
                                             OperatorHandle &A, Vector &X, Vector &B) = 0;
 
-   virtual void AddMult(const Vector &x, Vector &y, const double c=1.0) const = 0;
-   virtual void AddMultTranspose(const Vector &x, Vector &y,
-                                 const double c=1.0) const = 0;
-
    virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const = 0;
 
    virtual void Update() = 0;
@@ -287,7 +283,7 @@ public:
    /// Partial assembly of all internal integrators
    void Assemble();
 
-   void AddMult(const Vector &x, Vector &y, const double c) const;
+   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
 
    void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
 
diff --git a/fem/ceed/interface/operator.cpp b/fem/ceed/interface/operator.cpp
index d658a6d1f..fbda5f8ac 100644
--- a/fem/ceed/interface/operator.cpp
+++ b/fem/ceed/interface/operator.cpp
@@ -69,9 +69,11 @@ void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
 #endif
 }
 
-void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y) const
+void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
+                       const double a) const
 {
 #ifdef MFEM_USE_CEED
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    const CeedScalar *x_ptr;
    CeedScalar *y_ptr;
    CeedMemType mem;
diff --git a/fem/ceed/interface/operator.hpp b/fem/ceed/interface/operator.hpp
index 69e7a9a77..15eb95a40 100644
--- a/fem/ceed/interface/operator.hpp
+++ b/fem/ceed/interface/operator.hpp
@@ -38,7 +38,8 @@ public:
    Operator(CeedOperator op);
 #endif
    void Mult(const mfem::Vector &x, mfem::Vector &y) const override;
-   void AddMult(const mfem::Vector &x, mfem::Vector &y) const;
+   void AddMult(const mfem::Vector &x, mfem::Vector &y,
+                const double a = 1.0) const override;
    void GetDiagonal(mfem::Vector &diag) const;
    using mfem::Operator::SetupRAP;
    virtual ~Operator()
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index c582f7a61..ab169fda6 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -1958,7 +1958,7 @@ FiniteElementSpace::DerefinementOperator::DerefinementOperator(
          DenseMatrix &lM = localM[g](mi[s]);
          DenseMatrix &lR = localR[g](lR_offset+s);
          MultAtB(lP, lM, lR); // lR = lP^T lM
-         AddMult(lR, lP, lPtMP); // lPtMP += lP^T lM lP
+         mfem::AddMult(lR, lP, lPtMP); // lPtMP += lP^T lM lP
       }
       DenseMatrixInverse lPtMP_inv(lPtMP);
       for (int s = 0; s < nm; s++)
@@ -2005,7 +2005,7 @@ void FiniteElementSpace::DerefinementOperator
          x.GetSubVector(f_vdofs, loc_x);
          loc_x_mat.UseExternalData(loc_x.GetData(), f_vdofs.Size()/fine_vdim,
                                    fine_vdim);
-         AddMult(lR, loc_x_mat, loc_y_mat);
+         mfem::AddMult(lR, loc_x_mat, loc_y_mat);
       }
       y.SetSubVector(c_vdofs, loc_y);
    }
diff --git a/fem/multigrid.cpp b/fem/multigrid.cpp
index 08eaced11..d34e9edf1 100644
--- a/fem/multigrid.cpp
+++ b/fem/multigrid.cpp
@@ -14,41 +14,26 @@
 namespace mfem
 {
 
-Multigrid::Multigrid()
-   : cycleType(CycleType::VCYCLE), preSmoothingSteps(1), postSmoothingSteps(1)
+MultigridBase::MultigridBase()
+   : cycleType(CycleType::VCYCLE), preSmoothingSteps(1), postSmoothingSteps(1),
+     nrhs(0)
 {}
 
-Multigrid::Multigrid(const Array<Operator*>& operators_,
-                     const Array<Solver*>& smoothers_,
-                     const Array<Operator*>& prolongations_,
-                     const Array<bool>& ownedOperators_,
-                     const Array<bool>& ownedSmoothers_,
-                     const Array<bool>& ownedProlongations_)
-   : Solver(operators_.Last()->NumRows()), cycleType(CycleType::VCYCLE),
-     preSmoothingSteps(1), postSmoothingSteps(1),
-     X(operators_.Size()), Y(X.Size()), R(X.Size()), Z(X.Size())
+MultigridBase::MultigridBase(const Array<Operator*>& operators_,
+                             const Array<Solver*>& smoothers_,
+                             const Array<bool>& ownedOperators_,
+                             const Array<bool>& ownedSmoothers_)
+   : Solver(operators_.Last()->Height(), operators_.Last()->Width()),
+     cycleType(CycleType::VCYCLE), preSmoothingSteps(1), postSmoothingSteps(1),
+     nrhs(0)
 {
    operators_.Copy(operators);
    smoothers_.Copy(smoothers);
-   prolongations_.Copy(prolongations);
    ownedOperators_.Copy(ownedOperators);
    ownedSmoothers_.Copy(ownedSmoothers);
-   ownedProlongations_.Copy(ownedProlongations);
-
-   for (int level = 0; level < operators.Size(); ++level)
-   {
-      X[level] = new Vector(operators[level]->NumRows());
-      *X[level] = 0.0;
-      Y[level] = new Vector(operators[level]->NumRows());
-      *Y[level] = 0.0;
-      R[level] = new Vector(operators[level]->NumRows());
-      *R[level] = 0.0;
-      Z[level] = new Vector(operators[level]->NumRows());
-      *Z[level] = 0.0;
-   }
 }
 
-Multigrid::~Multigrid()
+MultigridBase::~MultigridBase()
 {
    for (int i = 0; i < operators.Size(); ++i)
    {
@@ -60,187 +45,234 @@ Multigrid::~Multigrid()
       {
          delete smoothers[i];
       }
-      delete X[i];
-      delete Y[i];
-      delete R[i];
-      delete Z[i];
    }
+   EraseVectors();
+}
 
-   for (int i = 0; i < prolongations.Size(); ++i)
+void MultigridBase::InitVectors() const
+{
+   if (X.NumRows() > 0 && X.NumCols() > 0) { EraseVectors(); }
+   const int M = NumLevels();
+   X.SetSize(M, nrhs);
+   Y.SetSize(M, nrhs);
+   R.SetSize(M, nrhs);
+   Z.SetSize(M, nrhs);
+   for (int i = 0; i < X.NumRows(); ++i)
    {
-      if (ownedProlongations[i])
+      const int n = operators[i]->Height();
+      for (int j = 0; j < X.NumCols(); ++j)
       {
-         delete prolongations[i];
+         X(i, j) = new Vector(n);
+         Y(i, j) = new Vector(n);
+         R(i, j) = new Vector(n);
+         Z(i, j) = new Vector(n);
       }
    }
+}
 
-   operators.DeleteAll();
-   smoothers.DeleteAll();
-   prolongations.DeleteAll();
-   X.DeleteAll();
-   Y.DeleteAll();
-   R.DeleteAll();
-   Z.DeleteAll();
+void MultigridBase::EraseVectors() const
+{
+   for (int i = 0; i < X.NumRows(); ++i)
+   {
+      for (int j = 0; j < X.NumCols(); ++j)
+      {
+         delete X(i, j);
+         delete Y(i, j);
+         delete R(i, j);
+         delete Z(i, j);
+      }
+   }
 }
 
-void Multigrid::AddLevel(Operator* opr, Solver* smoother, bool ownOperator,
-                         bool ownSmoother)
+void MultigridBase::AddLevel(Operator* op, Solver* smoother,
+                             bool ownOperator, bool ownSmoother)
 {
-   operators.Append(opr);
+   height = op->Height();
+   width = op->Width();
+   operators.Append(op);
    smoothers.Append(smoother);
    ownedOperators.Append(ownOperator);
    ownedSmoothers.Append(ownSmoother);
-   width = opr->Width();
-   height = opr->Height();
-
-   X.Append(new Vector(height));
-   *X.Last() = 0.0;
-   Y.Append(new Vector(height));
-   *Y.Last() = 0.0;
-   R.Append(new Vector(height));
-   *R.Last() = 0.0;
-   Z.Append(new Vector(height));
-   *Z.Last() = 0.0;
 }
 
-int Multigrid::NumLevels() const { return operators.Size(); }
-
-int Multigrid::GetFinestLevelIndex() const { return NumLevels() - 1; }
-
-const Operator* Multigrid::GetOperatorAtLevel(int level) const
-{
-   return operators[level];
-}
-
-Operator* Multigrid::GetOperatorAtLevel(int level)
-{
-   return operators[level];
-}
-
-const Operator* Multigrid::GetOperatorAtFinestLevel() const
-{
-   return GetOperatorAtLevel(operators.Size() - 1);
-}
-
-Operator* Multigrid::GetOperatorAtFinestLevel()
-{
-   return GetOperatorAtLevel(operators.Size() - 1);
-}
-
-Solver* Multigrid::GetSmootherAtLevel(int level) const
-{
-   return smoothers[level];
-}
-
-Solver* Multigrid::GetSmootherAtLevel(int level)
-{
-   return smoothers[level];
-}
-
-void Multigrid::SetCycleType(CycleType cycleType_, int preSmoothingSteps_,
-                             int postSmoothingSteps_)
+void MultigridBase::SetCycleType(CycleType cycleType_, int preSmoothingSteps_,
+                                 int postSmoothingSteps_)
 {
    cycleType = cycleType_;
    preSmoothingSteps = preSmoothingSteps_;
    postSmoothingSteps = postSmoothingSteps_;
 }
 
-void Multigrid::Mult(const Vector& x, Vector& y) const
+void MultigridBase::Mult(const Vector& x, Vector& y) const
 {
-   MFEM_ASSERT(NumLevels() > 0, "");
-   *X.Last() = x;
-   *Y.Last() = 0.0;
-   Cycle(GetFinestLevelIndex());
-   y = *Y.Last();
+   Array<const Vector*> X_(1);
+   Array<Vector*> Y_(1);
+   X_[0] = &x;
+   Y_[0] = &y;
+   Mult(X_, Y_);
 }
 
-void Multigrid::SetOperator(const Operator& op)
+void MultigridBase::Mult(const Array<const Vector*>& X_,
+                         Array<Vector*>& Y_) const
 {
-   MFEM_ABORT("SetOperator not supported in Multigrid");
+   MFEM_ASSERT(operators.Size() > 0,
+               "Multigrid solver does not have operators set!");
+   MFEM_ASSERT(X_.Size() == Y_.Size(),
+               "Number of columns mismatch in MultigridBase::Mult!");
+   if (iterative_mode)
+   {
+      MFEM_WARNING("Multigrid solver does not use iterative_mode and ignores "
+                   "the initial guess!");
+   }
+
+   // Add capacity as necessary
+   nrhs = X_.Size();
+   if (X.NumCols() < nrhs) { InitVectors(); }
+
+   // Perform a single cycle
+   const int M = NumLevels();
+   for (int j = 0; j < nrhs; ++j)
+   {
+      MFEM_ASSERT(X_[j] && Y_[j], "Missing Vector in MultigridBase::Mult!");
+      *X(M - 1, j) = *X_[j];
+      *Y(M - 1, j) = 0.0;
+   }
+   Cycle(M - 1);
+   for (int j = 0; j < nrhs; ++j)
+   {
+      *Y_[j] = *Y(M - 1, j);
+   }
 }
 
-void Multigrid::SmoothingStep(int level, bool transpose) const
+void MultigridBase::SmoothingStep(int level, bool zero, bool transpose) const
 {
-   GetOperatorAtLevel(level)->Mult(*Y[level], *R[level]); // r = A x
-   subtract(*X[level], *R[level], *R[level]);             // r = b - A x
-   if (transpose)
+   // y = y + S (x - A y) or y = y + S^T (x - A y)
+   if (zero)
    {
-      GetSmootherAtLevel(level)->MultTranspose(*R[level], *Z[level]); // z = S r
+      Array<Vector *> X_(X[level], nrhs), Y_(Y[level], nrhs);
+      GetSmootherAtLevel(level)->Mult(X_, Y_);
    }
    else
    {
-      GetSmootherAtLevel(level)->Mult(*R[level], *Z[level]); // z = S r
+      Array<Vector *> Y_(Y[level], nrhs), R_(R[level], nrhs),
+            Z_(Z[level], nrhs);
+      for (int j = 0; j < nrhs; ++j)
+      {
+         *R_[j] = *X(level, j);
+      }
+      GetOperatorAtLevel(level)->AddMult(Y_, R_, -1.0);
+      if (transpose)
+      {
+         GetSmootherAtLevel(level)->MultTranspose(R_, Z_);
+      }
+      else
+      {
+         GetSmootherAtLevel(level)->Mult(R_, Z_);
+      }
+      for (int j = 0; j < nrhs; ++j)
+      {
+         *Y_[j] += *Z_[j];
+      }
    }
-   add(*Y[level], 1.0, *Z[level], *Y[level]);             // x = x + S (b - A x)
 }
 
-void Multigrid::Cycle(int level) const
+void MultigridBase::Cycle(int level) const
 {
+   // Coarse solve
    if (level == 0)
    {
-      GetSmootherAtLevel(level)->Mult(*X[level], *Y[level]);
+      SmoothingStep(0, true, false);
       return;
    }
 
-   for (int i = 0; i < preSmoothingSteps; i++)
+   // Pre-smooth
+   for (int i = 0; i < preSmoothingSteps; ++i)
    {
-      SmoothingStep(level, false);
+      SmoothingStep(level, (cycleType == CycleType::VCYCLE && i == 0), false);
    }
 
-   // Compute residual
-   GetOperatorAtLevel(level)->Mult(*Y[level], *R[level]);
-   subtract(*X[level], *R[level], *R[level]);
-
-   // Restrict residual
-   GetProlongationAtLevel(level - 1)->MultTranspose(*R[level], *X[level - 1]);
-
-   // Init zeros
-   *Y[level - 1] = 0.0;
+   // Compute residual and restrict
+   {
+      Array<Vector *> Y_(Y[level], nrhs), R_(R[level], nrhs),
+            X_(X[level - 1], nrhs);
+      for (int j = 0; j < nrhs; ++j)
+      {
+         *R_[j] = *X(level, j);
+      }
+      GetOperatorAtLevel(level)->AddMult(Y_, R_, -1.0);
+      GetProlongationAtLevel(level - 1)->MultTranspose(R_, X_);
+      for (int j = 0; j < nrhs; ++j)
+      {
+         *Y(level - 1, j) = 0.0;
+      }
+   }
 
    // Corrections
-   int corrections = 1;
+   Cycle(level - 1);
    if (cycleType == CycleType::WCYCLE)
-   {
-      corrections = 2;
-   }
-   for (int correction = 0; correction < corrections; ++correction)
    {
       Cycle(level - 1);
    }
 
-   // Prolongate
-   GetProlongationAtLevel(level - 1)->Mult(*Y[level - 1], *R[level]);
-
-   // Add update
-   *Y[level] += *R[level];
+   // Prolongate and add
+   {
+      Array<Vector *> Y_(Y[level - 1], nrhs), Z_(Z[level], nrhs);
+      GetProlongationAtLevel(level - 1)->Mult(Y_, Z_);
+      for (int j = 0; j < nrhs; ++j)
+      {
+         *Y(level, j) += *Z_[j];
+      }
+   }
 
    // Post-smooth
-   for (int i = 0; i < postSmoothingSteps; i++)
+   for (int i = 0; i < postSmoothingSteps; ++i)
    {
-      SmoothingStep(level, true);
+      SmoothingStep(level, false, true);
    }
 }
 
-const Operator* Multigrid::GetProlongationAtLevel(int level) const
+Multigrid::Multigrid()
+   : MultigridBase()
+{}
+
+Multigrid::Multigrid(const Array<Operator*>& operators_,
+                     const Array<Solver*>& smoothers_,
+                     const Array<Operator*>& prolongations_,
+                     const Array<bool>& ownedOperators_,
+                     const Array<bool>& ownedSmoothers_,
+                     const Array<bool>& ownedProlongations_)
+   : MultigridBase(operators_, smoothers_, ownedOperators_, ownedSmoothers_)
 {
-   return prolongations[level];
+   prolongations_.Copy(prolongations);
+   ownedProlongations_.Copy(ownedProlongations);
+}
+
+Multigrid::~Multigrid()
+{
+   for (int i = 0; i < prolongations.Size(); ++i)
+   {
+      if (ownedProlongations[i])
+      {
+         delete prolongations[i];
+      }
+   }
 }
 
+GeometricMultigrid::
+GeometricMultigrid(const FiniteElementSpaceHierarchy& fespaces_)
+   : MultigridBase(), fespaces(fespaces_)
+{}
+
 GeometricMultigrid::~GeometricMultigrid()
 {
    for (int i = 0; i < bfs.Size(); ++i)
    {
       delete bfs[i];
    }
-
-   bfs.DeleteAll();
-
    for (int i = 0; i < essentialTrueDofs.Size(); ++i)
    {
       delete essentialTrueDofs[i];
    }
-
-   essentialTrueDofs.DeleteAll();
 }
 
 void GeometricMultigrid::FormFineLinearSystem(Vector& x, Vector& b,
@@ -256,9 +288,4 @@ void GeometricMultigrid::RecoverFineFEMSolution(const Vector& X,
    bfs.Last()->RecoverFEMSolution(X, b, x);
 }
 
-const Operator* GeometricMultigrid::GetProlongationAtLevel(int level) const
-{
-   return fespaces.GetProlongationAtLevel(level);
-}
-
 } // namespace mfem
diff --git a/fem/multigrid.hpp b/fem/multigrid.hpp
index 1e3869dd3..91bfea251 100644
--- a/fem/multigrid.hpp
+++ b/fem/multigrid.hpp
@@ -21,8 +21,8 @@
 namespace mfem
 {
 
-/// Multigrid solver class
-class Multigrid : public Solver
+/// Abstract base class for Multigrid solvers
+class MultigridBase : public Solver
 {
 public:
    enum class CycleType
@@ -34,65 +34,72 @@ public:
 protected:
    Array<Operator*> operators;
    Array<Solver*> smoothers;
-   Array<Operator*> prolongations;
-
    Array<bool> ownedOperators;
    Array<bool> ownedSmoothers;
-   Array<bool> ownedProlongations;
 
    CycleType cycleType;
    int preSmoothingSteps;
    int postSmoothingSteps;
 
-   mutable Array<Vector*> X;
-   mutable Array<Vector*> Y;
-   mutable Array<Vector*> R;
-   mutable Array<Vector*> Z;
+   mutable Array2D<Vector*> X, Y, R, Z;
+   mutable int nrhs;
 
 public:
-   /// Constructs an empty multigrid hierarchy.
-   Multigrid();
+   /// Constructs an empty multigrid hierarchy
+   MultigridBase();
 
-   /// Constructs a multigrid hierarchy from the given inputs.
-   /** Inputs include operators and smoothers on all levels, prolongation
-       operators that go from coarser to finer levels, and ownership of the
-       given operators, smoothers, and prolongations. */
-   Multigrid(const Array<Operator*>& operators_, const Array<Solver*>& smoothers_,
-             const Array<Operator*>& prolongations_, const Array<bool>& ownedOperators_,
-             const Array<bool>& ownedSmoothers_, const Array<bool>& ownedProlongations_);
+   /// Constructs a multigrid hierarchy from the given inputs
+   /** Inputs include operators and smoothers on all levels, and ownership of
+       the given operators and smoothers */
+   MultigridBase(const Array<Operator*>& operators_,
+                 const Array<Solver*>& smoothers_,
+                 const Array<bool>& ownedOperators_,
+                 const Array<bool>& ownedSmoothers_);
 
    /// Destructor
-   virtual ~Multigrid();
+   virtual ~MultigridBase();
 
-   /// Adds a level to the multigrid operator hierarchy.
+   /// Adds a level to the multigrid operator hierarchy
    /** The ownership of the operators and solvers/smoothers may be transferred
-       to the Multigrid by setting the according boolean variables. */
-   void AddLevel(Operator* opr, Solver* smoother, bool ownOperator,
+       to the Multigrid by setting the according boolean variables */
+   void AddLevel(Operator* op, Solver* smoother, bool ownOperator,
                  bool ownSmoother);
 
    /// Returns the number of levels
-   int NumLevels() const;
+   int NumLevels() const { return operators.Size(); }
 
    /// Returns the index of the finest level
-   int GetFinestLevelIndex() const;
-
-   /// Returns operator at given level
-   const Operator* GetOperatorAtLevel(int level) const;
+   int GetFinestLevelIndex() const { return NumLevels() - 1; }
 
    /// Returns operator at given level
-   Operator* GetOperatorAtLevel(int level);
-
-   /// Returns operator at finest level
-   const Operator* GetOperatorAtFinestLevel() const;
+   const Operator* GetOperatorAtLevel(int level) const
+   {
+      return operators[level];
+   }
+   Operator* GetOperatorAtLevel(int level)
+   {
+      return operators[level];
+   }
 
    /// Returns operator at finest level
-   Operator* GetOperatorAtFinestLevel();
-
-   /// Returns smoother at given level
-   Solver* GetSmootherAtLevel(int level) const;
+   const Operator* GetOperatorAtFinestLevel() const
+   {
+      return GetOperatorAtLevel(GetFinestLevelIndex());
+   }
+   Operator* GetOperatorAtFinestLevel()
+   {
+      return GetOperatorAtLevel(GetFinestLevelIndex());
+   }
 
    /// Returns smoother at given level
-   Solver* GetSmootherAtLevel(int level);
+   const Solver* GetSmootherAtLevel(int level) const
+   {
+      return smoothers[level];
+   }
+   Solver* GetSmootherAtLevel(int level)
+   {
+      return smoothers[level];
+   }
 
    /// Set cycle type and number of pre- and post-smoothing steps used by Mult
    void SetCycleType(CycleType cycleType_, int preSmoothingSteps_,
@@ -100,23 +107,62 @@ public:
 
    /// Application of the multigrid as a preconditioner
    virtual void Mult(const Vector& x, Vector& y) const override;
+   virtual void Mult(const Array<const Vector*>& X_,
+                     Array<Vector*>& Y_) const override;
 
    /// Not supported for multigrid
-   virtual void SetOperator(const Operator& op) override;
+   virtual void SetOperator(const Operator& op) override
+   {
+      MFEM_ABORT("SetOperator is not supported in Multigrid!");
+   }
 
 private:
-   /// Application of a smoothing step at particular level
-   void SmoothingStep(int level, bool transpose) const;
-
    /// Application of a multigrid cycle at particular level
    void Cycle(int level) const;
 
+   /// Application of a pre-/post-smoothing step at particular level
+   void SmoothingStep(int level, bool zero, bool transpose) const;
+
+   /// Allocate or destroy temporary storage
+   void InitVectors() const;
+   void EraseVectors() const;
+
    /// Returns prolongation operator at given level
-   virtual const Operator* GetProlongationAtLevel(int level) const;
+   virtual const Operator* GetProlongationAtLevel(int level) const = 0;
+};
+
+/// Multigrid solver class
+class Multigrid : public MultigridBase
+{
+protected:
+   Array<Operator*> prolongations;
+   Array<bool> ownedProlongations;
+
+public:
+   /// Constructs an empty multigrid hierarchy
+   Multigrid();
+
+   /// Constructs a multigrid hierarchy from the given inputs
+   /** Inputs include operators and smoothers on all levels, prolongation
+       operators that go from coarser to finer levels, and ownership of the
+       given operators, smoothers, and prolongations */
+   Multigrid(const Array<Operator*>& operators_, const Array<Solver*>& smoothers_,
+             const Array<Operator*>& prolongations_, const Array<bool>& ownedOperators_,
+             const Array<bool>& ownedSmoothers_, const Array<bool>& ownedProlongations_);
+
+   /// Destructor
+   virtual ~Multigrid();
+
+private:
+   /// Returns prolongation operator at given level
+   virtual const Operator* GetProlongationAtLevel(int level) const override
+   {
+      return prolongations[level];
+   }
 };
 
 /// Geometric multigrid associated with a hierarchy of finite element spaces
-class GeometricMultigrid : public Multigrid
+class GeometricMultigrid : public MultigridBase
 {
 protected:
    const FiniteElementSpaceHierarchy& fespaces;
@@ -126,8 +172,7 @@ protected:
 public:
    /** Construct an empty multigrid object for the given finite element space
        hierarchy @a fespaces_ */
-   GeometricMultigrid(const FiniteElementSpaceHierarchy& fespaces_)
-      : Multigrid(), fespaces(fespaces_) { }
+   GeometricMultigrid(const FiniteElementSpaceHierarchy& fespaces_);
 
    /// Destructor
    virtual ~GeometricMultigrid();
@@ -142,7 +187,10 @@ public:
 
 private:
    /// Returns prolongation operator at given level
-   virtual const Operator* GetProlongationAtLevel(int level) const override;
+   virtual const Operator* GetProlongationAtLevel(int level) const override
+   {
+      return fespaces.GetProlongationAtLevel(level);
+   }
 };
 
 } // namespace mfem
diff --git a/fem/prestriction.cpp b/fem/prestriction.cpp
index 19b9f593d..5a9103dc1 100644
--- a/fem/prestriction.cpp
+++ b/fem/prestriction.cpp
@@ -91,8 +91,10 @@ void ParNCH1FaceRestriction::NonconformingInterpolation(Vector& y) const
    });
 }
 
-void ParNCH1FaceRestriction::AddMultTranspose(const Vector &x, Vector &y) const
+void ParNCH1FaceRestriction::AddMultTranspose(const Vector &x, Vector &y,
+                                              const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    NonconformingTransposeInterpolation(x);
    H1FaceRestriction::AddMultTranspose(x_interp, y);
@@ -774,8 +776,10 @@ void ParNCL2FaceRestriction::Mult(const Vector& x, Vector& y) const
    }
 }
 
-void ParNCL2FaceRestriction::AddMultTranspose(const Vector &x, Vector &y) const
+void ParNCL2FaceRestriction::AddMultTranspose(const Vector &x, Vector &y,
+                                              const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    if (type==FaceType::Interior)
    {
diff --git a/fem/prestriction.hpp b/fem/prestriction.hpp
index c42888edd..a3e05dccb 100644
--- a/fem/prestriction.hpp
+++ b/fem/prestriction.hpp
@@ -65,8 +65,10 @@ public:
                      requested by @a type in the constructor.
                      The face_dofs should be ordered according to the given
                      ElementDofOrdering.
-       @param[in,out] y The L-vector degrees of freedom. */
-   void AddMultTranspose(const Vector &x, Vector &y) const override;
+       @param[in,out] y The L-vector degrees of freedom.
+       @param[in]  a Scalar coefficient for addition. */
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
@@ -302,8 +304,10 @@ public:
                      requested by @a type in the constructor.
                      The face_dofs should be ordered according to the given
                      ElementDofOrdering
-       @param[in,out] y The L-vector degrees of freedom. */
-   void AddMultTranspose(const Vector &x, Vector &y) const override;
+       @param[in,out] y The L-vector degrees of freedom.
+       @param[in]  a Scalar coefficient for addition. */
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
diff --git a/fem/restriction.cpp b/fem/restriction.cpp
index b499c842c..ce96dc7d7 100644
--- a/fem/restriction.cpp
+++ b/fem/restriction.cpp
@@ -148,7 +148,7 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
 }
 
 template <bool ADD>
-void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y) const
+void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -180,13 +180,15 @@ void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y) const
 void ElementRestriction::MultTranspose(const Vector& x, Vector& y) const
 {
    constexpr bool ADD = false;
-   AddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(x, y);
 }
 
-void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y) const
+void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                          const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   AddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(x, y);
 }
 
 void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
@@ -521,7 +523,7 @@ void L2ElementRestriction::Mult(const Vector &x, Vector &y) const
 }
 
 template <bool ADD>
-void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y) const
+void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
 {
    const int nd = ndof;
    const int vd = vdim;
@@ -544,13 +546,15 @@ void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y) const
 void L2ElementRestriction::MultTranspose(const Vector &x, Vector &y) const
 {
    constexpr bool ADD = false;
-   AddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(x, y);
 }
 
-void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y) const
+void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
+                                            const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   AddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(x, y);
 }
 
 void L2ElementRestriction::FillI(SparseMatrix &mat) const
@@ -760,8 +764,10 @@ void H1FaceRestriction::Mult(const Vector& x, Vector& y) const
    });
 }
 
-void H1FaceRestriction::AddMultTranspose(const Vector& x, Vector& y) const
+void H1FaceRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                         const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
    const int nface_dofs = face_dofs;
@@ -1266,8 +1272,10 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
    });
 }
 
-void L2FaceRestriction::AddMultTranspose(const Vector& x, Vector& y) const
+void L2FaceRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                         const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    if (m == L2FaceValues::DoubleValued)
    {
@@ -2050,8 +2058,10 @@ void NCL2FaceRestriction::DoubleValuedNonconformingTransposeInterpolationInPlace
    });
 }
 
-void NCL2FaceRestriction::AddMultTranspose(const Vector& x, Vector& y) const
+void NCL2FaceRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                           const double a) const
 {
+   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    if (type==FaceType::Interior)
    {
diff --git a/fem/restriction.hpp b/fem/restriction.hpp
index fdb925813..cf6c46431 100644
--- a/fem/restriction.hpp
+++ b/fem/restriction.hpp
@@ -27,7 +27,8 @@ class ElementRestrictionOperator : public Operator
 public:
    /// @brief Add the E-vector degrees of freedom @a x to the L-vector degrees
    /// of freedom @a y.
-   virtual void AddMultTranspose(const Vector &x, Vector &y) const = 0;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override = 0;
 };
 
 /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
@@ -65,9 +66,10 @@ protected:
 
 public:
    ElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
-   void Mult(const Vector &x, Vector &y) const;
-   void MultTranspose(const Vector &x, Vector &y) const;
-   void AddMultTranspose(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
+   void MultTranspose(const Vector &x, Vector &y) const override;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
    /// Compute Mult without applying signs based on DOF orientations.
    void MultUnsigned(const Vector &x, Vector &y) const;
@@ -99,7 +101,7 @@ public:
    ///
    /// Performs either MultTranspose or AddMultTranspose depending on the
    /// boolean template parameter @a ADD.
-   template <bool ADD> void AddMultTranspose(const Vector &x, Vector &y) const;
+   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /// Operator that converts L2 FiniteElementSpace L-vectors to E-vectors.
@@ -116,9 +118,10 @@ class L2ElementRestriction : public ElementRestrictionOperator
    const int ndofs;
 public:
    L2ElementRestriction(const FiniteElementSpace&);
-   void Mult(const Vector &x, Vector &y) const;
-   void MultTranspose(const Vector &x, Vector &y) const;
-   void AddMultTranspose(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
+   void MultTranspose(const Vector &x, Vector &y) const override;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
        given by this ElementRestriction. */
    void FillI(SparseMatrix &mat) const;
@@ -129,7 +132,7 @@ public:
    ///
    /// Performs either MultTranspose or AddMultTranspose depending on the
    /// boolean template parameter @a ADD.
-   template <bool ADD> void AddMultTranspose(const Vector &x, Vector &y) const;
+   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /** An enum type to specify if only e1 value is requested (SingleValued) or both
@@ -180,8 +183,10 @@ public:
        @param[in]     x The face degrees of freedom on the face.
        @param[in,out] y The L-vector of degrees of freedom to which we add the
                         face degrees of freedom.
+       @param[in]     a Scalar coefficient for addition.
    */
-   virtual void AddMultTranspose(const Vector &x, Vector &y) const = 0;
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const override = 0;
 
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y. Perform the same computation as AddMultTranspose, but
@@ -277,8 +282,10 @@ public:
                      requested by @a type in the constructor.
                      The face_dofs should be ordered according to the given
                      ElementDofOrdering
-       @param[in,out] y The L-vector degrees of freedom. */
-   void AddMultTranspose(const Vector &x, Vector &y) const override;
+       @param[in,out] y The L-vector degrees of freedom.
+       @param[in]  a Scalar coefficient for addition. */
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
 private:
    /** @brief Compute the scatter indices: L-vector to E-vector, and the offsets
@@ -409,8 +416,10 @@ public:
                      requested by @a type in the constructor.
                      The face_dofs should be ordered according to the given
                      ElementDofOrdering
-       @param[in,out] y The L-vector degrees of freedom. */
-   void AddMultTranspose(const Vector &x, Vector &y) const override;
+       @param[in,out] y The L-vector degrees of freedom.
+       @param[in]  a Scalar coefficient for addition. */
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
    /** @brief Fill the I array of SparseMatrix corresponding to the sparsity
        pattern given by this L2FaceRestriction.
@@ -831,8 +840,10 @@ public:
                      requested by @a type in the constructor.
                      The face_dofs should be ordered according to the given
                      ElementDofOrdering
-       @param[in,out] y The L-vector degrees of freedom. */
-   void AddMultTranspose(const Vector &x, Vector &y) const override;
+       @param[in,out] y The L-vector degrees of freedom.
+       @param[in]  a Scalar coefficient for addition. */
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
diff --git a/fem/tbilinearform.hpp b/fem/tbilinearform.hpp
index 2069de066..f137841ee 100644
--- a/fem/tbilinearform.hpp
+++ b/fem/tbilinearform.hpp
@@ -615,6 +615,7 @@ public:
          solFES.VectorAssemble(y_dof.layout, y_dof, solVecLayoutLoc, y);
       }
    }
+   using Operator::AddMult;
 };
 
 } // namespace mfem
diff --git a/linalg/complex_operator.hpp b/linalg/complex_operator.hpp
index da0f4142e..a060702c5 100644
--- a/linalg/complex_operator.hpp
+++ b/linalg/complex_operator.hpp
@@ -111,6 +111,9 @@ public:
    virtual void Mult(const Vector &x, Vector &y) const;
    virtual void MultTranspose(const Vector &x, Vector &y) const;
 
+   using Operator::Mult;
+   using Operator::MultTranspose;
+
    virtual Type GetType() const { return Complex_Operator; }
 
    Convention GetConvention() const { return convention_; }
diff --git a/linalg/densemat.cpp b/linalg/densemat.cpp
index 17efa5a9a..2c2927255 100644
--- a/linalg/densemat.cpp
+++ b/linalg/densemat.cpp
@@ -221,8 +221,13 @@ void DenseMatrix::MultTranspose(const Vector &x, Vector &y) const
    MultTranspose((const double *)x, (double *)y);
 }
 
-void DenseMatrix::AddMult(const Vector &x, Vector &y) const
+void DenseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
 {
+   if (a != 1.0)
+   {
+      AddMult_a(a, x, y);
+      return;
+   }
    MFEM_ASSERT(height == y.Size() && width == x.Size(),
                "incompatible dimensions");
 
@@ -239,8 +244,14 @@ void DenseMatrix::AddMult(const Vector &x, Vector &y) const
    }
 }
 
-void DenseMatrix::AddMultTranspose(const Vector &x, Vector &y) const
+void DenseMatrix::AddMultTranspose(const Vector &x, Vector &y,
+                                   const double a) const
 {
+   if (a != 1.0)
+   {
+      AddMultTranspose_a(a, x, y);
+      return;
+   }
    MFEM_ASSERT(height == x.Size() && width == y.Size(),
                "incompatible dimensions");
 
diff --git a/linalg/densemat.hpp b/linalg/densemat.hpp
index 49395eb13..32f6cc7bd 100644
--- a/linalg/densemat.hpp
+++ b/linalg/densemat.hpp
@@ -150,11 +150,15 @@ public:
    /// Multiply a vector with the transpose matrix.
    virtual void MultTranspose(const Vector &x, Vector &y) const;
 
-   /// y += A.x
-   void AddMult(const Vector &x, Vector &y) const;
+   using Operator::Mult;
+   using Operator::MultTranspose;
 
-   /// y += A^t x
-   void AddMultTranspose(const Vector &x, Vector &y) const;
+   /// y += a * A.x
+   virtual void AddMult(const Vector &x, Vector &y, const double a = 1.0) const;
+
+   /// y += a * A^t x
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const;
 
    /// y += a * A.x
    void AddMult_a(double a, const Vector &x, Vector &y) const;
@@ -839,6 +843,8 @@ public:
    /// Multiply the inverse matrix by another matrix: X <- A^{-1} X.
    void Mult(DenseMatrix &X) const {factors->Solve(width, X.Width(), X.Data());}
 
+   using Operator::Mult;
+
    /// Compute and return the inverse matrix in Ainv.
    void GetInverseMatrix(DenseMatrix &Ainv) const;
 
diff --git a/linalg/hypre.hpp b/linalg/hypre.hpp
index f48b8fe05..421066be4 100644
--- a/linalg/hypre.hpp
+++ b/linalg/hypre.hpp
@@ -599,7 +599,7 @@ public:
    void MergeDiagAndOffd(SparseMatrix &merged);
 
    /// Return the diagonal of the matrix (Operator interface).
-   virtual void AssembleDiagonal(Vector &diag) const { GetDiag(diag); }
+   void AssembleDiagonal(Vector &diag) const override { GetDiag(diag); }
 
    /** Split the matrix into M x N equally sized blocks of parallel matrices.
        The size of 'blocks' must already be set to M x N. */
@@ -649,7 +649,7 @@ public:
        partitioning array. */
    HYPRE_BigInt *GetColStarts() const { return hypre_ParCSRMatrixColStarts(A); }
 
-   virtual MemoryClass GetMemoryClass() const { return GetHypreMemoryClass(); }
+   MemoryClass GetMemoryClass() const override { return GetHypreMemoryClass(); }
 
    /// Ensure the action of the transpose is performed fast.
    /** When HYPRE is built for GPUs, this method will construct and store the
@@ -691,16 +691,25 @@ public:
        transpose. */
    void MultTranspose(double a, const Vector &x, double b, Vector &y) const;
 
-   virtual void Mult(const Vector &x, Vector &y) const
+   void Mult(const Vector &x, Vector &y) const override
    { Mult(1.0, x, 0.0, y); }
 
    /// Computes y = A^t * x
    /** If the matrix is modified, call ResetTranspose() and optionally
        EnsureMultTranspose() to make sure this method uses the correct updated
        transpose. */
-   virtual void MultTranspose(const Vector &x, Vector &y) const
+   void MultTranspose(const Vector &x, Vector &y) const override
    { MultTranspose(1.0, x, 0.0, y); }
 
+   void AddMult(const Vector &x, Vector &y, const double a = 1.0) const override
+   { Mult(a, x, 1.0, y); }
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override
+   { MultTranspose(a, x, 1.0, y); }
+
+   using Operator::Mult;
+   using Operator::MultTranspose;
+
    /** @brief Computes y = a * |A| * x + b * y, using entry-wise absolute values
        of the matrix A. */
    void AbsMult(double a, const Vector &x, double b, Vector &y) const;
@@ -1080,6 +1089,7 @@ public:
    /// Relax the linear system Ax=b
    virtual void Mult(const HypreParVector &b, HypreParVector &x) const;
    virtual void Mult(const Vector &b, Vector &x) const;
+   using Operator::Mult;
 
    /// Apply transpose of the smoother to relax the linear system Ax=b
    virtual void MultTranspose(const Vector &b, Vector &x) const;
@@ -1156,6 +1166,7 @@ public:
    virtual void Mult(const HypreParVector &b, HypreParVector &x) const;
    /// Solve the linear system Ax=b
    virtual void Mult(const Vector &b, Vector &x) const;
+   using Operator::Mult;
 
    ///@}
 
diff --git a/linalg/operator.cpp b/linalg/operator.cpp
index 236f86d5c..b409afa29 100644
--- a/linalg/operator.cpp
+++ b/linalg/operator.cpp
@@ -48,6 +48,68 @@ void Operator::InitTVectors(const Operator *Po, const Operator *Ri,
    }
 }
 
+void Operator::AddMult(const Vector &x, Vector &y, const double a) const
+{
+   mfem::Vector z(y.Size());
+   Mult(x, z);
+   y.Add(a, z);
+}
+
+void Operator::AddMultTranspose(const Vector &x, Vector &y,
+                                const double a) const
+{
+   mfem::Vector z(y.Size());
+   MultTranspose(x, z);
+   y.Add(a, z);
+}
+
+void Operator::Mult(const Array<const Vector *> &X, Array<Vector *> &Y) const
+{
+   MFEM_ASSERT(X.Size() == Y.Size(),
+               "Number of columns mismatch in Operator::Mult!");
+   for (int i = 0; i < X.Size(); i++)
+   {
+      MFEM_ASSERT(X[i] && Y[i], "Missing Vector in Operator::Mult!");
+      Mult(*X[i], *Y[i]);
+   }
+}
+
+void Operator::MultTranspose(const Array<const Vector *> &X,
+                             Array<Vector *> &Y) const
+{
+   MFEM_ASSERT(X.Size() == Y.Size(),
+               "Number of columns mismatch in Operator::MultTranspose!");
+   for (int i = 0; i < X.Size(); i++)
+   {
+      MFEM_ASSERT(X[i] && Y[i], "Missing Vector in Operator::MultTranspose!");
+      MultTranspose(*X[i], *Y[i]);
+   }
+}
+
+void Operator::AddMult(const Array<const Vector *> &X, Array<Vector *> &Y,
+                       const double a) const
+{
+   MFEM_ASSERT(X.Size() == Y.Size(),
+               "Number of columns mismatch in Operator::AddMult!");
+   for (int i = 0; i < X.Size(); i++)
+   {
+      MFEM_ASSERT(X[i] && Y[i], "Missing Vector in Operator::AddMult!");
+      AddMult(*X[i], *Y[i], a);
+   }
+}
+
+void Operator::AddMultTranspose(const Array<const Vector *> &X,
+                                Array<Vector *> &Y, const double a) const
+{
+   MFEM_ASSERT(X.Size() == Y.Size(),
+               "Number of columns mismatch in Operator::AddMultTranspose!");
+   for (int i = 0; i < X.Size(); i++)
+   {
+      MFEM_ASSERT(X[i] && Y[i], "Missing Vector in Operator::AddMultTranspose!");
+      AddMultTranspose(*X[i], *Y[i], a);
+   }
+}
+
 void Operator::FormLinearSystem(const Array<int> &ess_tdof_list,
                                 Vector &x, Vector &b,
                                 Operator* &Aout, Vector &X, Vector &B,
diff --git a/linalg/operator.hpp b/linalg/operator.hpp
index 60b988954..cc258431c 100644
--- a/linalg/operator.hpp
+++ b/linalg/operator.hpp
@@ -92,13 +92,37 @@ public:
    /** @brief Action of the transpose operator: `y=A^t(x)`. The default behavior
        in class Operator is to generate an error. */
    virtual void MultTranspose(const Vector &x, Vector &y) const
-   { mfem_error("Operator::MultTranspose() is not overloaded!"); }
+   { mfem_error("Operator::MultTranspose() is not overridden!"); }
+
+   /// Operator application: `y+=A(x)` (default) or `y+=a*A(x)`.
+   virtual void AddMult(const Vector &x, Vector &y, const double a = 1.0) const;
+
+   /// Operator transpose application: `y+=A^t(x)` (default) or `y+=a*A^t(x)`.
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const;
+
+   /// Operator application on a matrix: `Y=A(X)`.
+   virtual void Mult(const Array<const Vector *> &X, Array<Vector *> &Y) const;
+
+   /// Action of the transpose operator on a matrix: `Y=A^t(X)`.
+   virtual void MultTranspose(const Array<const Vector *> &X,
+                              Array<Vector *> &Y) const;
+
+   /// Operator application on a matrix: `Y+=A(X)` (default) or `Y+=a*A(X)`.
+   virtual void AddMult(const Array<const Vector *> &X, Array<Vector *> &Y,
+                        const double a = 1.0) const;
+
+   /** @brief Operator transpose application on a matrix: `Y+=A^t(X)` (default)
+       or `Y+=a*A^t(X)`. */
+   virtual void AddMultTranspose(const Array<const Vector *> &X,
+                                 Array<Vector *> &Y,
+                                 const double a = 1.0) const;
 
    /** @brief Evaluate the gradient operator at the point @a x. The default
        behavior in class Operator is to generate an error. */
    virtual Operator &GetGradient(const Vector &x) const
    {
-      mfem_error("Operator::GetGradient() is not overloaded!");
+      mfem_error("Operator::GetGradient() is not overridden!");
       return const_cast<Operator &>(*this);
    }
 
diff --git a/linalg/petsc.hpp b/linalg/petsc.hpp
index 8ba0bd96e..724afc9e7 100644
--- a/linalg/petsc.hpp
+++ b/linalg/petsc.hpp
@@ -441,12 +441,20 @@ public:
    /// Matvec transpose: @a y = @a a A^T @a x + @a b @a y.
    void MultTranspose(double a, const Vector &x, double b, Vector &y) const;
 
-   virtual void Mult(const Vector &x, Vector &y) const
+   void Mult(const Vector &x, Vector &y) const override
    { Mult(1.0, x, 0.0, y); }
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const
+   void MultTranspose(const Vector &x, Vector &y) const override
    { MultTranspose(1.0, x, 0.0, y); }
 
+   void AddMult(const Vector &x, Vector &y,
+                const double a = 1.0) const override
+   { Mult(a, x, 1.0, y); }
+
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override
+   { MultTranspose(a, x, 1.0, y); }
+
    /// Get the associated MPI communicator
    MPI_Comm GetComm() const;
 
diff --git a/linalg/solvers.hpp b/linalg/solvers.hpp
index 476186bee..aa3230ce2 100644
--- a/linalg/solvers.hpp
+++ b/linalg/solvers.hpp
@@ -1196,6 +1196,7 @@ public:
    virtual void MultTranspose(const Vector &x, Vector &y) const { Mult(x, y, true); }
    virtual void SetOperator(const Operator &op) { }
    HypreSmoother& GetSmoother() { return *aux_smoother_.As<HypreSmoother>(); }
+   using Operator::Mult;
 };
 #endif // MFEM_USE_MPI
 
diff --git a/linalg/sparsemat.hpp b/linalg/sparsemat.hpp
index 74cb797eb..b86ccd565 100644
--- a/linalg/sparsemat.hpp
+++ b/linalg/sparsemat.hpp
@@ -349,20 +349,21 @@ public:
    virtual void Mult(const Vector &x, Vector &y) const;
 
    /// y += A * x (default)  or  y += a * A * x
-   void AddMult(const Vector &x, Vector &y, const double a = 1.0) const;
+   virtual void AddMult(const Vector &x, Vector &y,
+                        const double a = 1.0) const;
 
    /// Multiply a vector with the transposed matrix. y = At * x
    /** If the matrix is modified, call ResetTranspose() and optionally
        EnsureMultTranspose() to make sure this method uses the correct updated
        transpose. */
-   void MultTranspose(const Vector &x, Vector &y) const;
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
 
    /// y += At * x (default)  or  y += a * At * x
    /** If the matrix is modified, call ResetTranspose() and optionally
        EnsureMultTranspose() to make sure this method uses the correct updated
        transpose. */
-   void AddMultTranspose(const Vector &x, Vector &y,
-                         const double a = 1.0) const;
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const;
 
    /** @brief Build and store internally the transpose of this matrix which will
        be used in the methods AddMultTranspose(), MultTranspose(), and
